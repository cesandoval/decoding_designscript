import("ProtoGeometry.dll");
import("Math.dll");

//Returns the normalized bisector of two vectors.
def bisector(v0,v1)
{
    v0 = v0.Normalize();
    v1 = v1.Normalize();
    x = Sum({ v0.X, v1.X }) / 2;
    y = Sum({ v0.Y, v1.Y }) / 2;
    z = Sum({ v0.Z, v1.Z }) / 2;
    return = Vector.ByCoordinates(x, y, z);
}

rad_small = 5.06;
rad_large = 26.14;
divs = 50;
mid_pt = 0.35;
height = 8.00;
strength = 2.80;

// Create the interior and exterior circles 
cir1 = Point.AtParameter(Circle.ByCenterPointRadius(Point.ByCoordinates(0, 0, 0), rad_small),0..1..#divs); 
cir2 = Point.AtParameter(Circle.ByCenterPointRadius(Point.ByCoordinates(0, 0, 0), rad_large),0..1..#divs);

// Move the points of the larger circle up with sine values.
humps = 3;
sine = (Math.Sin(Math.RadiansToDegrees(0..Math.PI * 2 * humps..#divs)) + 1) * strength; //[(math.sin(i) + 1) * strength for i in Interval(0, math.pi * 2 * humps).divide(divs)];

cir2 = cir2.Translate(0, 0, sine);
mid = Point.AtParameter(Line.ByStartPointEndPoint(cir1, cir2),mid_pt).Translate(0,0,height); //{  cir1 , cir2};
crvs = { };
[Imperative]
{
    for(i in 0..divs - 1)
    {
        if (i%2 == 0)
            {crvs[Count(crvs)] = BSplineCurve.ByPoints({ cir1[i], mid[i], cir2[i] });}
        else
            {crvs[Count(crvs)] = BSplineCurve.ByPoints({ cir2[i], mid[i], cir1[i] });}
    }
}

// Get the first perpendicular vector
def perp_vec(vec1, vec2, pt)
{
    // Get the bisector of vec1 and vec2
    bisecs = bisector(-vec1, vec2);
    // Get the perpendicular vector to the bisector
    return = bisecs.Cross(CoordinateSystem.ByOriginVectors(pt, bisecs, Vector.ByCoordinates(0, 0, 1)).ZAxis).Normalize();
}




/*
# Divide a curve with the given points into segments and arcs
def divide_crv(pt_a,pt_b,vec):
    tan = vec * rad
    # Move the point with the tan vector
    new_pt = pt_a + tan
    # Find the tangent point on a circle from a given point
    pt = Segment(new_pt, pt_b).eval(0.5)
    cir1 = Circle(Plane(new_pt, CS(new_pt,tan,Vec(0,0,-1)).z_axis),rad)
    cir2 = Circle(Plane(pt, CS(pt,tan,Vec(0,0,-1)).z_axis),pt.distance(new_pt))
    # Get the intersections between the circles to get the tangent points
    xsec = Intersector()
    if xsec.of(cir1,cir2):
        inters = xsec._geom
    # Only keep the intersection point closer to the original point
    if len(inters)>1:
        segs = [Segment(pt_a,inter) for inter in inters]
        segs.sort(key=lambda seg: seg.length)   
        inters = segs[0].ept
    # Create a straight segment
    ln = Segment(inters, pt_b)
    # Get the angle between the tan and a new vector from the intersection to the center pt
    angle = tan.angle(Vec(inters,new_pt))
    # Create the arc 
    cross_vec = tan.cross(CS(new_pt,tan,Vec(new_pt,pt_b)).z_axis).inverted()
    arc = Arc(CS(new_pt,-tan,cross_vec), rad, angle)
    return  arc, ln
*/

crv_divs = 10;
// Divide the crvs in 4 pts 
t = 0..1..#crv_divs;
pts = Point.AtParameter(crvs<1>,t<2>);

/*
for i, crv in enumerate(crvs):
    # Divide the crvs in Segments and Arcs
    # Get the first Sement and Arc
    new_crvs = [divide_crv(pts[0],pts[1],perp_vec(Vec(0,0,-1),Vec(pts[0],pts[1]),pts[0]))]
    # With the perpendicular vector, loop throught the remaining points to create new Arcs and Segments
    for n in range(1,len(pts)-1):
        vec = -new_crvs[n-1][1].vec.cross(CS(pts[n],-new_crvs[n-1][1].vec,Vec(0,0,1)).z_axis).normalized()
        new_crvs.append(divide_crv(pts[n],pts[n+1],vec))
        
    b.put(new_crvs)

*/