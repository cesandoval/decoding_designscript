import("ProtoGeometry.dll");
import("Math.dll");

/*
Vector Functions
*/

// returns the angle between 2 vectors
def angle(vec1, vec2)
{
    vdot = vec1.Dot(vec2) / (vec1.Length * vec2.Length);
    [Imperative]
    {
        if (vdot > 1.0)
            vdot = 1.0;
        if (vdot < -1.0)
            vdot = -1.0;
    }
    return = Math.Acos(vdot);
}

// Returns a new vector limited to a given length.
def limited(vector, n)
{
    new_vec = vector.Length < n ? vector : vector.Normalize().Scale(n);
    return = new_vec;
}

// creates a vector from two given points
def vec_two_points(spt, ept)
{
    return =  Vector.ByCoordinates(ept.X - spt.X, ept.Y - spt.Y, ept.Z - spt.Z);
}
    
//Returns the normalized bisector of two vectors.
def bisector(v0,v1)
{
    v0 = v0.Normalize();
    v1 = v1.Normalize();
    x = Sum({ v0.X, v1.X }) / 2;
    y = Sum({ v0.Y, v1.Y }) / 2;
    z = Sum({ v0.Z, v1.Z }) / 2;
    return = Vector.ByCoordinates(x, y, z);
}

// creates a vector from a given line
def vec_from_line(line)
{
    return = vec_two_points(StartPoint, EndPoint);
}



/*
Coordinate System Functions
*/

// Returns a coordinate system on the world xy plane. The rotation value controls the rotation of the cs.
def on_xy_rotate(rot)
{
    x_vec = Vector.ByCoordinates(Math.Cos(Math.RadiansToDegrees(rot)), Math.Sin(Math.RadiansToDegrees(rot)), 0);
    return = CoordinateSystem.ByOriginVectors(Point.ByCoordinates(0, 0, 0), x_vec, x_vec.Cross(Vector.ByCoordinates(0, 0, -1)));
}



/*
Arc Functions
*/

def from_tan(spt, ept, tan)
{
    vec_ab = Vector.ByCoordinates(ept.X - spt.X, ept.Y - spt.Y, ept.Z - spt.Z);
    vec_rad = tan.Cross(tan.Cross(vec_ab));
    ang = angle(vec_ab, vec_rad);
    rad = vec_ab.Length / Math.Cos(ang) / 2.0;
    center = spt.Translate(vec_rad, -rad);// this should be positive
    return = Arc.ByCenterPointStartPointSweepPoint(center, spt, ept);
}



/*
PGon functions
*/

// Rotates the vertices in this object.
def rotate(pgon,n)
{
    n = n > Count(pgon.Vertices)-1 ? n%Count(pgon.Vertices) : n;
    n = n < -Count(pgon.Vertices) - 1 ? -Math.Abs(n)%Count(pgon.Vertices) : n;
    verts = SetUnion(pgon.Vertices[n..Count(pgon.Vertices) - 1], pgon.Vertices[0..n]);
    return = Polygon.ByVertices(verts);
}



/*
Point Functions
*/

// Returns a new point that results from adding this point's world coordinates to the other point's (or vector's) world coordinates.
def point_addition(p1, p2)
{
    return = Point.ByCoordinates(p1.X + p2.X, p1.Y + p2.Y, p1.Z + p2.Z);
}

// Returns a new point that results from dividing each of this point's world coordinates by the value provided.
def point_division(pt, factor)
{
    return = Point.ByCoordinates(pt.X / factor, pt.Y / factor, pt.Z / factor);
}



/*
Curve Functions
*/

// Decomposes a curve into subcurves
def decompose_curve(curve, divs)
{
    return = Line.ByStartPointEndPoint(Point.AtParameter(curve, 0..1-1/divs..1/divs), Point.AtParameter(curve, 1/divs..1..1/divs));
}